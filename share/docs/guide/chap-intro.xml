<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
	"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="chap-intro">
	<title>Introduction</title>

	<para>This chapter will first walk you through the standard features and
	behavior of the framework and then explain how to bootstrap and configure
	your new application. At the end of this chapter you will have a better
	idea of how the framework is working. You will then be ready to start
	working on your first application.</para>

	<sect1 id="chap-intro-layout">
		<title>Directory layout</title>

		<para>Every project must have a well structured directory layout in
		order to allow continued maintenance. A good layout enables a team
		to communicate and work together easily and enables newcomers to
		familiarise themselves with the project in minimal time.</para>

<programlisting>
project/
	app/			Project-specific files.
		cli/		The command-line interface tools for this application.
		conf/		Configuration files of the application.
		form/		The form definitions of the application.
		locale/		The gettext objects for localization.
		php/		The php code of the project, such as code for the frames and model.
		sql/		The database schema, upgrade scripts and other SQL files.
		tmp/		Temporary files generated by the application, including the various cache files.
		tpl/		The templates for the application.
	pub/			A directory for storing any resources directly accessible to the user, like stylesheets and images.
	res/			Public resources distributed with the framework.
	share/
	tools/
	wee/			The Web:Extend framework.
		vendor/		The third party libraries embedded in the framework.
	index.php		The bootstrap file of the application.</programlisting>

		<note>
			<para>Directory names should be lowercase and as short as possible.
			Project-speficic files should only be located in
			<filename>app/</filename> and <filename>pub/</filename>. The only
			folders accessible via HTTP should be <filename>pub/</filename>
			and <filename>res/</filename>. The boostrap file
			<filename>index.php</filename> can be modified to suit the needs of
			the application.</para>
		</note>

		<para>As you can see, the framework does not enforce any layout for
		your PHP and template files. In fact the framework does not enforce
		any layout, everything is freely configurable. Different applications
		benefit from different layouts. We will describe two layouts commonly
		used.</para>

		<sect2 id="chap-intro-layout-small">
			<title>Small application layout</title>

			<para>If you are writing a small application you'll probably want
			to keep the layout as simple as possible. We advice you to:</para>

			<itemizedlist>
				<listitem><para>Store all template and form files at the root
				of their respective folders.</para></listitem>

				<listitem><para>Store the domain model in
				<filename>app/php/model/</filename>, the frames in
				<filename>app/php/frames/</filename> and the other PHP files
				directly in <filename>app/php/</filename>.</para></listitem>
			</itemizedlist>
		</sect2>

		<sect2 id="chap-intro-layout-modular">
			<title>Modular application layout</title>

			<para>A modular application can be broken down into various modules
			each with a specific scope. The simplest modular application is one
			with separate interfaces for public and private operations. Both
			interfaces complement each other but there is no direct dependency
			between one or the other. They simply operate on the same
			data, accessed through the domain model.</para>

			<para>We can simply add one subfolder per module wherever needed
			to organize our project by module:</para>

<programlisting>
app/form/
	private/
	public/
app/php/
	model/
	private/
	public/
app/tpl/
	private/
	public/</programlisting>
		</sect2>

		<sect2>
			<title>Third party libraries</title>

			<para>All third party libraries not available through addons
			should be stored into their own subfolder. By convention the
			<filename>app/php/vendor/</filename> folder is used.</para>

			<para>For example, if we were to use the
			<ulink url="http://framework.zend.com">Zend Framework</ulink>
			library in our project, we would install it in the
			<filename>app/php/vendor/zendframework/</filename> folder.</para>
		</sect2>
	</sect1>

	<sect1 id="chap-intro-db-versioning">
		<title>Database versioning</title>

		<para>While there are tools readily available for file versioning,
		like <application>git</application> or
		<application>subversion</application>, there isn't as many solutions
		for database versioning. Maybe you're already using one. If you
		aren't, we have a simple solution for you. To put it short, you can
		use the <filename>app/sql/</filename> folder to store upgrade scripts
		of your databases.</para>

		<para>Keep track of a version number for your database. It doesn't have
		to be related to the repository version, simply start from version 1
		and increment with each change you make. Include that version number in
		the latest upgrade script you write to make sure upgrades are always
		ran in the correct order. Also save the latest schema into its own
		file whenever you make any change, to allow easier setup of new
		development environments.</para>

		<para>The following filenames are used by convention:</para>

		<itemizedlist>
			<listitem><para>Use <filename>schema.sql</filename> for your schema
			file. It's OK to always overwrite it with the latest schema as it
			represents the schema for this revision.</para></listitem>

			<listitem><para>Use <filename>upgrade.1.sql</filename> for your
			first upgrade script, then increment the version number with each
			new script: <filename>upgrade.2.sql</filename>,
			<filename>upgrade.3.sql</filename>, and so on.</para></listitem>

			<listitem><para>If you have more than one database or schema in
			your project, name your files accordingly:
			<filename>frontend.schema.sql</filename> along with
			<filename>frontend.upgrade.1.sql</filename>, for
			example.</para></listitem>
		</itemizedlist>
	</sect1>

	<sect1 id="chap-intro-autoload">
		<title>Autoload</title>

		<para><ulink url="http://php.net/autoload">Autoload</ulink> is a PHP
		feature that tries to automatically load a class file, on the fly,
		whenever an undefined class is encountered.</para>

		<para>Web:Extend provides its own autoload handler through the
		<literal>weeAutoload</literal> class. Its method
		<literal>loadClass</literal> is called everytime a class has to be
		loaded.</para>

		<para><literal>weeAutoload</literal> finds the files to load from a
		list of paths. By default this includes <filename>wee/</filename> and
		<filename>app/php/</filename>. It automatically scans the given paths
		and caches the list of files for all subsequent requests. Additional
		paths can be added by calling the static method
		<literal>addPath</literal> in your bootstrap file.</para>

		<para>To be included automatically, a class must be saved in the
		appropriate path with a filename of the form
		<filename>CLASSNAME.class.php</filename> with
		<literal>CLASSNAME</literal> the name of the class.</para>

		<para>Caching is done automatically but requires the web server to
		have write access to the <filename>app/tmp/</filename> folder. The
		autoload cache file is <filename>app/tmp/autoload.php</filename> by
		default. This filename can be changed by defining the constant
		<literal>WEE_AUTOLOAD_CACHE</literal> in your bootstrap script.</para>

		<para>Caching is enabled by default, but is disabled when
		<literal>DEBUG</literal> is defined to avoid to manually clear the
		cache everytime you add a new class to your project and thus ease
		development. Defining the constant <literal>NO_CACHE</literal> will
		also disable caching. Both constants disable all forms of caching in
		your application. If you only wish to disable the autoload cache,
		comment the constant definition for
		<literal>WEE_AUTOLOAD_CACHE</literal>.</para>

		<warning>
			<para>It is not recommended to disable autoload caching as this
			will greatly reduce the performance of your application. Autoload
			often makes up to 70% of the processing time when caching is
			disabled. While this is no concern for development, this is not
			recommended in production.</para>

			<para>A quick way to see whether cache is running is to check for
			the existence of the cache file
			<filename>app/tmp/autoload.php</filename>. It will only exist
			when autoload caching is enabled and running as expected.</para>
		</warning>
	</sect1>

	<sect1 id="chap-intro-error-handling">
		<title>Error handling</title>

		<para>Web:Extend does not return error values. Whenever an error is
		encountered, an exception is thrown. This is also true for all PHP
		errors, including the PHP errors in your own code.</para>

		<note>
			<para>Web:Extend overrides the PHP errors with a standard
			<ulink url="http://php.net/errorexception">ErrorException</ulink>.
			That basically makes all recoverable errors catchable.</para>

			<para>Note that all catchable errors throw exceptions, regardless
			of the value set through
			<ulink url="http://php.net/error_reporting">error_reporting</ulink>
			or its ini configuration equivalent.</para>
		</note>

		<para>There's two kinds of exceptions: logical and runtime. Logical
		exceptions are thrown when something is wrong in the application's
		design itself; for example if a parameter is of the wrong type. Runtime
		exceptions can only be detected when the application is running;
		for example if a user sends an unexpected value.</para>

		<para>It is good practice to catch these exceptions where you can
		expect errors and display a meaningful message to the user. No need to
		catch everything though! If you don't, Web:Extend will handle it and
		display a customizable error page.</para>

		<caution>
			<para>While it is always best to detect all errors early, you
			should take extra care to throw exceptions when continuing the
			script execution would result in an illegal state, rendering for
			example an object useless or making a UI component display
			impossible values.</para>
		</caution>

		<para>The error page contains generic information about the error and
		a few instructions to help the user of the application. When
		<literal>DEBUG</literal> is enabled, the page will also contain a
		detailed report on the error, including a trace.</para>

		<para>You can customize the error page by calling
		<literal>weeException::setErrorPage</literal> with the path to the
		error page file you want to use. This file is a PHP script and can
		contain PHP or HTML code. Debugging data is available through the
		<literal>$aDebug</literal> variable if you wish to use it.</para>

		<para>The file <filename>res/wee/error.html</filename> is the default
		error page. You can use it as a detailed example when setting up your
		own custom error page.</para>

		<sect2 id="chap-intro-error-handling-safe">
			<title>Safely throwing exceptions</title>

			<para>We recommend you do not use the <literal>throw</literal>
			construct directly. If you make a typo in the exception's name,
			it will result in a fatal error.</para>

			<para>The framework defines the function <literal>burn</literal>
			for that purpose. It takes two parameters: the exception name and
			its associated error message. The function will throw a
			<literal>DoubleFaultException</literal> if the exception class
			doesn't exist, allowing you to recover from that kind of mistake
			in critical sections of your application. Indeed, catching
			<literal>Exception</literal> will allow you to recover from your
			typo or any other error if you really need a script to terminate
			properly.</para>

			<para>The following example demonstrates how to use the function
			<literal>burn</literal> to throw exceptions safely:</para>

			<xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
				href="examples/build/chap-intro-burn.php.xml"/>
		</sect2>

		<sect2 id="chap-intro-error-handling-shut-up">
			<title>Using the shut-up operator <literal>@</literal></title>

			<para>This operator should generally not be used. There are however
			a few cases where its use is benefitial:</para>

			<itemizedlist>
				<listitem><para>When it makes more sense to throw a specific
				exception rather than
				<literal>ErrorException</literal>.</para></listitem>

				<listitem><para>When the target code must never fail. Note
				that this case is very rare.</para></listitem>
			</itemizedlist>

			<para>A common example of the second case would be including and
			using code from a third party library. Many third party libraries
			trigger various warnings that would result in exceptions unless
			the operator is used to silence them.</para>

			<para>Try to avoid using it on an instruction that might include
			or parse a PHP file, as it would mask the error and display a
			blank page. If a third party library triggers exceptions just by
			including it, consider finding another library for this
			task.</para>
		</sect2>

		<sect2 id="chap-intro-error-handling-categories">
			<title>Exception categories</title>

			<para>Exceptions can be sorted into three categories.</para>

			<para><emphasis>Error exceptions</emphasis> are triggered by PHP
			errors. They generally should not be caught and the script should
			be terminated when they are encountered. Any different kind of
			exception should be expected where it makes sense to catch and
			handle the error.</para>

			<para><emphasis>Standard exceptions</emphasis> include both logical
			and runtime exceptions. They should be used when it is recommended
			to catch and handle the error. Examples include
			<literal>FileNotFoundException</literal> and
			<literal>BadXMLException</literal>.</para>

			<para><emphasis>Specific exceptions</emphasis> are associated with
			a specific component of the framework or the application. The
			developer is required to catch them to determine whether an action
			was successful. Examples include
			<literal>FormValidationException</literal>,
			<literal>AuthenticationException</literal> and
			<literal>RouteNotFoundException</literal>.</para>

			<para><emphasis>Standard exceptions</emphasis> and
			<emphasis>specific exceptions</emphasis> should be documented
			properly.</para>
		</sect2>
	</sect1>

	<sect1 id="chap-intro-bootstrap">
		<title>Bootstrap</title>

		<para>The bootstrap file is the entry point of the application. All
		requests are typically sent directly to a single bootstrap file that
		initializes the application, processes the request and outputs a
		response. The default bootstrap file is
		<filename>index.php</filename>.</para>

		<para>The bootstrap file's work can be divided in three significant
		steps:</para>

		<orderedlist>
			<listitem><para>Define the framework's environmental constants
			(for example: <literal>DEBUG</literal> mode).</para></listitem>

			<listitem><para>Load the framework.</para></listitem>

			<listitem><para>Initialize and start the
			application.</para></listitem>
		</orderedlist>

		<para>The simplest bootstrap code is only two lines long:</para>

		<xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
			href="examples/build/chap-intro-minimal-bootstrap.php.xml"/>

		<para>Past these lines you can directly write your own code if such
		was your intent. It is a good solution for writing command-line
		scripts for managing your project. Everything else should use the
		default bootstrap file, though.</para>

		<para>Most of the bootstrap configurations will be explained in their
		respective chapters. We will however list the most important options
		right now, so that you are aware of their availability when you need
		to use them.</para>

		<itemizedlist>
			<listitem><para><literal>DEBUG</literal>: The most important
			configuration option. When defined (regardless of the value),
			it will activate <literal>DEBUG</literal> mode. This mode is
			intended for development only. It will disable all the caching
			done by the framework and provide complete debugging messages
			and tools for all situations.</para></listitem>

			<listitem><para><literal>NO_CACHE</literal>: Simply disable
			all forms of caching in the framework. Useful when you need to
			quickly investigate whether an error comes from caching in a
			production environment.</para></listitem>

			<listitem><para><literal>APP_PATH</literal>: URL containing the
			path to the application. Should be a fully-formed URL. Useful
			when the default URL guessed by the framework turns out
			incorrect.</para></listitem>

			<listitem><para><literal>ROOT_PATH</literal>: Path to the
			application's root folder. It is the folder containing the
			default bootstrap file and the <filename>wee/</filename>
			subfolder. Useful when writing command-line scripts stored in
			a different location, like a subfolder.</para></listitem>

			<listitem><para><literal>PHP_EXT</literal>: Extension used by
			the PHP files. Defaults to <literal>'.php'</literal>. Useful
			when the webserver requires a special extension to work
			correctly, like <literal>'.php5'</literal>.</para></listitem>
		</itemizedlist>

		<para>The bootstrap file can also be used to define functions that
		must be made available to the whole application. For example, the
		extra library is included by default after loading the framework and
		provide a few utility functions to simplify your application's
		development.</para>
	</sect1>

	<sect1 id="chap-intro-conf">
		<title>Configuration</title>

		<para>Configuration is a central part of any project. It allows you
		to keep settings out of your code and centralize them in a common
		location. Web:Extend uses configuration files to store all these
		settings. A configuration file can be used to store database
		credentials, session settings and more.</para>

		<para>The configuration file format is designed for ease of use above
		anything. It also handles multiple environments allowing you to write
		a single configuration file for all your development, test and
		production environments. The format is not designed for PHP execution
		speed, in the sense that it has to be parsed by PHP. However the file
		is only loaded once and then cached so there is no actual performance
		issue.</para>

		<para>Let's see how the format works. Each individual configuration
		options will be explained in their respective chapters. You can open
		the sample configuration file located in
		<filename>share/conf/sample.cnf</filename> to get a quick overview of
		the file format. Note that it also contains sane default values that
		can be used when starting a new project.</para>

		<para>The format is basically a list of key/value tuples. A few
		additional instructions are provided to allow for host-specific
		configuration inside a common configuration file.</para>

		<para>A key can be specified more than once. Only the last tuple
		defined will be kept after loading the configuration file. This
		tuple can be different depending on the environment if you use
		host-specific configuration. That means you can define a default
		value and then override it when the environment meets some specific
		conditions.</para>

		<para>Configuration files use Perl-like comments. Any line beginning
		with <literal>#</literal> is a comment.</para>

<programlisting>
# this is a comment</programlisting>

		<para>Configuration files can include other files. You can include a
		file in three different ways demonstrated here:</para>

<programlisting>
include //relative_to_root_path
include ./relative_to_current_file
include relative_to_current_working_directory</programlisting>

		<para>Generally you're going to want the second option, as it'll look
		into the folder where the current configuration file is located.</para>

		<para>Finally, configuration files can use target instructions. These
		instructions allow you to create a single configuration file for all
		your environments. The best way to achieve this is to have sane default
		values and to override them on specific environments. For example you
		could define the database password like this:</para>

<programlisting>
db.password                          = default_password
$(host dev.example.com).db.password  = a_different_password
$(host test.example.com).db.password = another_password</programlisting>

		<para>The second line will be discarded if the hostname does not match
		<literal>dev.example.com</literal>. The third will be discarded if the
		hostname does not match <literal>test.example.com</literal>, as you
		probably expected. It is good practice to put the production value by
		default and to override that value depending on your
		environment.</para>

		<para>The syntax for target instructions is as follow:</para>

<programlisting>
$(function [param1] [param2] [...] target).key = value</programlisting>

		<para>You can also use a target instruction on an include statement.
		The file will only be included if the condition is met. This allows
		you to separate your configuration in multiple files, one per
		environment.</para>

<programlisting>
$(function [param1] [param2] [...] target).include ./my.cnf</programlisting>

		<note>
			<para>Do not forget the dot after the closing parenthesis.</para>
		</note>

		<para>The following table lists all supported targets:</para>

		<table>
			<title>List of configuration targets</title>

			<tgroup cols="3">
				<thead>
					<row>
						<entry>Function</entry>
						<entry>Parameters</entry>
						<entry>Description</entry>
					</row>
				</thead>

				<tbody>
					<row>
						<entry><literal>os</literal></entry>
						<entry>None.</entry>
						<entry><emphasis>Operating System name</emphasis>, e.g.
						<literal>NetBSD</literal>. The equivalent PHP call is
						<literal>php_uname('s')</literal>.</entry>
					</row>

					<row>
						<entry><literal>host</literal></entry>
						<entry>None.</entry>
						<entry><emphasis>Hostname</emphasis>, e.g.
						<literal>localhost</literal> or
						<literal>example.com</literal>. The equivalent PHP
						call is <literal>php_uname('n')</literal>.</entry>
					</row>

					<row>
						<entry><literal>phpver</literal></entry>
						<entry>None.</entry>
						<entry><emphasis>PHP version</emphasis>. The equivalent
						PHP call is <literal>php_version()</literal>.</entry>
					</row>

					<row>
						<entry><literal>extver</literal></entry>
						<entry>Name of the PHP extension.</entry>
						<entry><emphasis>Given PHP extension's
						version</emphasis>. The equivalent PHP call is
						<literal>php_version($sExtension)</literal>.</entry>
					</row>

					<row>
						<entry><literal>sapi</literal></entry>
						<entry>None.</entry>
						<entry><emphasis>Interface type</emphasis>. The
						equivalent PHP call is
						<literal>php_sapi_name()</literal>.</entry>
					</row>

					<row>
						<entry><literal>path</literal></entry>
						<entry>None.</entry>
						<entry><emphasis>Application path</emphasis>. Path
						where the bootstrap file and the
						<filename>wee/</filename> folder are located.</entry>
					</row>

					<row>
						<entry><literal>isfile</literal></entry>
						<entry>None.</entry>
						<entry><emphasis>Whether the target file
						exists</emphasis>.</entry>
					</row>

					<row>
						<entry><literal>isdir</literal></entry>
						<entry>None.</entry>
						<entry><emphasis>Whether the target directory
						exists</emphasis>.</entry>
					</row>
				</tbody>
			</tgroup>
		</table>

		<para><literal>isfile</literal> and <literal>isdir</literal> use the
		same path rules as the <literal>include</literal> statement. So you
		probably want to prefix your filenames with <literal>./</literal> in
		most cases.</para>

		<note>
			<para>A cool trick is to include a configuration file only if it
			exists. This allows you to add specific overrides using a file that
			won't necessarily be added into the source code repository. It
			could store credentials to critical systems that developers aren't
			allowed to access, for example.</para>

			<para>To do this, simply use the target instruction
			<literal>isfile</literal> on an <literal>include</literal>
			statement.</para>

<programlisting>
$(isfile ./my.cnf).include ./my.cnf</programlisting>

			<para>It will only include <filename>./my.cnf</filename> if the
			file exists, and will proceed normally otherwise.</para>
		</note>
	</sect1>
</chapter>
